\section{Analisi Funzionale}%
\label{sec:analisi_funzionale}

\subsection{Sito Web}%
\label{sub:sito_web}

Il sito web pu\`o essere implementato usando qualsiasi framework, sarebbe ideale utilizzare framework con rendering veloce per permettere un'apertura veloce delle applicazioni PWA\@. La dimensione delle librerie non \`e importante siccome possono essere salvate integralmente nella memoria del dispositivo. Ho deciso di utilizzare React perch\`e ho avuto esperienza personale con il framework e vanilla Javascript.

Sar\`a necessario aggiungere i manifesti iOS e Android per permettere l'installazione del sito web come applicazione Progressive Web App, inoltre sar\`a necessario creare il pacchetto d'installazione dell'applicazione se si vuole pubblicare all'interno degli store Google e Apple. L'installazione tramite bottone \`e possibile anche senza compilare il bundle applicativo.

Per quanto riguarda la sicurezza della trasmissione di dati \`e sufficiente implementare il protocollo HTTPS nel server API, \`e quindi richiesto un certificato TLS/SSL che garantisca l'autenticit\`a e l'integrit\`a delle informazioni trasmesse. I certificati possono essere acquistati da enti certificatori (Certification Authority) ma un certificato semplice potrebbe essere gi\`a incluso con la registrazione del dominio o con l'hosting cloud. Il sito web non richiede protezione HTTPS siccome le informazioni trasmesse tra il sito e il visitatore sono statiche e non contengono informazioni personali tuttavia \`e conveniente installare un certificato semplice per non scoraggiare gli utenti all'inserimento di dati personali.

Ho scelto di utilizzare Cloudflare per proteggere il sito web, offre certificati SSL gratuiti ma \`e necessaria completa fiducia in Cloudflare siccome hanno accesso alle comunicazioni in chiaro (in dettaglio nella Sezione~\ref{sub:certificati}). Il certificato Cloudflare verr\`a usato solo per il sito web statico che non contiene informazioni personali quindi non costituisce un problema per noi.

\subsection{API}%
\label{sub:api}

La maggior parte delle web API di questo millennio hanno utilizzato la tecnologia REST (Representational state transfer), che associa ogni richiesta GET ad un'informazione e ogni richiesta POST, PUT, PATCH o DELETE ad un'azione, negli ultimi anni per\`o, le applicazioni web hanno iniziato ad introdurre numerose informazioni su singole pagine e la metodologia REST non scala con il numero di informazioni, infatti per ogni informazione l'utente deve inviare una nuova richiesta al server API\@. Per ovviare a questo problema \`e nato GraphQL\@.

GraphQL permette di richiedere solo le informazioni necessarie, riducendo le informazioni superflue ricevute in risposta dal server, inoltre permette di richiedere pi\`u informazioni insieme, ad esempio non \`e necessario ottenere prima le informazioni sulla spiaggia e poi i posti disponibili ma \`e possibile richiedere entrambe le informazioni nello stesso momento e anche per pi\`u spiagge alla volta, riducendo il numero di richieste da centinaia ad una sola~\cite{graphql-website}.

Quindi la scelta della tipologia di API ricade su GraphQL ma le scelte non finiscono qui, infatti ora \`e necessario scegliere il linguaggio di programmazione da utilizzare per l'implementazione del servizio GraphQL\@. Sono disponibili librerie per ogni linguaggio ma ho deciso di utilizzare la libreria \href{https://github.com/graphql-rust/juniper}{Juniper} nel linguaggio Rust.

Rust \`e un linguaggio sviluppato da Mozilla con enfasi sulla sicurezza e sulla velocit\`a. Raggiunge velocit\`a equivalenti o superiori al linguaggio C ma le regole del linguaggio impediscono categoricamente la maggior parte delle vulnerabilit\`a ricorrenti nel linguaggio C~\cite{rust-website}. Lo sviluppo di applicazioni Rust non \`e semplice rispetto a linguaggi moderni come C\# e Javascript tuttavia la sua velocit\`a e la sua affidabilit\`a non \`e neanche confrontabile con questi linguaggi.

Rust riesce ad ottenere questa sicurezza tramite le restrizioni sull'utilizzo della memoria, infatti puntatori nulli o invalidi non sono permessi e non \`e possibile incorrere in \emph{race conditions}, inoltre non \`e presente un \emph{Garbage Collector} all'interno di Rust, le risorse sono acquisite durante l'inizializzazione e liberate quando escono fuori dallo \emph{scope}.

\subsection{Database}%
\label{sub:database}

Ho deciso di utilizzare il sistema di gestione di database \emph{PostgreSQL}. Il DBMS rispetta lo standard ISO ma offre numerose funzionalit\`a aggiuntive come il tipo \emph{text} per contenere stringhe di dimensione variabile. Il database deve essere installato in prossimit\`a del server API per ridurre il ritardo di comunicazione. Un secondo database \`e richiesto per salvare informazioni sensibili e il \emph{salt} utilizzato per crittografare le password degli utenti.

Le API si occuperanno di interfacciarsi con il Database. Ho scelto di utilizzare la libreria \href{https://diesel.rs/}{Diesel} per la comunicazione con il Database siccome \`e integrato molto bene con la libreria Juniper.

\subsection{Pagamento elettronico}%
\label{sub:pagamento_elettronico}

Per permettere ai clienti di prenotare spiagge private \`e necessario implementare un servizio di e-commerce. Analizzando le varie possibilit\`a il servizio pi\`u adatto mi \`e sembrato essere \emph{PayPal Checkout}, le API sono semplici da integrare nel sito web e permette di pagare sia con PayPal che con Carte di Credito. Anche \emph{I-Beach} utilizza questo servizio.

\subsection{Generazione codice QR}

Ogni prenotazione ha un codice QR associato tuttavia non \`e possibile utilizzare il campo ``reservations.id'' del database (Sezione~\ref{sec:modelloer}) per generare il codice QR siccome \`e un campo che incrementa di uno ad ogni riga della tabella, rendendo quindi prevedibile l'identificativo delle prenotazioni successive a quella di un cliente. Se il codice QR fosse generato esclusivamente utilizzando il campo ID, chiunque abbia esperienza con attacchi informatici sarebbe in grado di utilizzare le prenotazioni di altri come se fosse sue. Per rendere univoco e imprevedibile il codice QR ho deciso di concatenare l'identificativo dell'utente che ha prenotato la spiaggia al numero della prenotazione, in questo modo sarebbe necessario prevedere anche chi ha prenotato la spiaggia oltre al numero della prenotazione.
